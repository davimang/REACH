\documentclass[12pt, titlepage]{article}

\usepackage{amsmath, mathtools}

\usepackage[round]{natbib}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{colortbl}
\usepackage{xr}
\usepackage{hyperref}
\usepackage{longtable}
\usepackage{xfrac}
\usepackage{tabularx}
\usepackage{float}
\usepackage{siunitx}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage[section]{placeins}
\usepackage{caption}
\usepackage{fullpage}

\hypersetup{
bookmarks=true,     % show bookmarks bar?
colorlinks=true,       % false: boxed links; true: colored links
linkcolor=red,          % color of internal links (change box color with linkbordercolor)
citecolor=blue,      % color of links to bibliography
filecolor=magenta,  % color of file links
urlcolor=cyan          % color of external links
}

\usepackage{array}

\externaldocument{../../SRS/SRS}

\input{../../Comments}
\input{../../Common}

\begin{document}

\title{Module Interface Specification for \progname{}}

\author{\authname}

\date{\today}

\maketitle

\pagenumbering{roman}

\section{Revision History}

\begin{tabularx}{\textwidth}{p{3cm}p{2cm}X}
\toprule {\bf Date} & {\bf Version} & {\bf Notes}\\
\midrule
Date 1 & 1.0 & Notes\\
Date 2 & 1.1 & Notes\\
\bottomrule
\end{tabularx}

~\newpage

\section{Symbols, Abbreviations and Acronyms}

See SRS Documentation at \wss{give url}

\wss{Also add any additional symbols, abbreviations or acronyms}

\newpage

\tableofcontents

\newpage

\pagenumbering{arabic}

\section{Introduction}

The following document details the Module Interface Specifications for
REACH, a web application used to improve patients' access to clinical 
trials and practitioners' access to potential participants. More specifically,
it will provide the list of modules that have been decomposed from the Module Guide,
each with their interface specification, detailing important characteristics such as 
the module's methods and state variables.

Complementary documents, such as the System Requirement Specifications
and Module Guide can be found at \url{https://github.com/davimang/REACH}.

\section{Notation}

The structure of the MIS for modules comes from \citet{HoffmanAndStrooper1995},
with the addition that template modules have been adapted from
\cite{GhezziEtAl2003}.  The mathematical notation comes from Chapter 3 of
\citet{HoffmanAndStrooper1995}.  For instance, the symbol := is used for a
multiple assignment statement and conditional rules follow the form $(c_1
\Rightarrow r_1 | c_2 \Rightarrow r_2 | ... | c_n \Rightarrow r_n )$.

The following table summarizes the primitive data types used by \progname. 

\begin{center}
\renewcommand{\arraystretch}{1.2}
\noindent 
\begin{tabular}{l l p{7.5cm}} 
\toprule 
\textbf{Data Type} & \textbf{Notation} & \textbf{Description}\\ 
\midrule
character & char & a single symbol or digit\\
integer & $\mathbb{Z}$ & a number without a fractional component in (-$\infty$, $\infty$) \\
natural number & $\mathbb{N}$ & a number without a fractional component in [1, $\infty$) \\
real & $\mathbb{R}$ & any number in (-$\infty$, $\infty$)\\
\bottomrule
\end{tabular} 
\end{center}

\noindent
The specification of \progname \ uses some derived data types: sequences, strings, and
tuples. Sequences are lists filled with elements of the same data type. Strings
are sequences of characters. Tuples contain a list of values, potentially of
different types. In addition, \progname \ uses functions, which
are defined by the data types of their inputs and outputs. Local functions are
described by giving their type signature followed by their specification.

\section{Module Decomposition}

The following table is taken directly from the Module Guide document for this project.

\begin{table}[h!]
\centering
\begin{tabular}{p{0.3\textwidth} p{0.6\textwidth}}
\toprule
\textbf{Level 1} & \textbf{Level 2}\\
\midrule

{Hardware-Hiding} & ~ \\
\midrule

\multirow{7}{0.3\textwidth}{Behaviour-Hiding} & Input Parameters\\
& Output Format\\
& Output Verification\\
& Temperature ODEs\\
& Energy Equations\\ 
& Control Module\\
& Specification Parameters Module\\
\midrule

\multirow{3}{0.3\textwidth}{Software Decision} & {Sequence Data Structure}\\
& ODE Solver\\
& Plotting\\
\bottomrule

\end{tabular}
\caption{Module Hierarchy}
\label{TblMH}
\end{table}

\newpage
~\newpage

\section{MIS of the User data module} \label{User}

\subsection{Module}

User

\subsection{Uses}
PatientInfo, Trial

\subsection{Syntax}

\subsubsection{Exported Constants}
None

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{4cm} p{4cm} p{4cm} p{4cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
getName & - & seq of char & - \\
\hline
setName & seq of char & - & EmptyName \\
\hline
getEmail & - & seq of char & - \\
\hline
setEmail & seq of char & - & InvalidEmail \\
\hline
getInfoProfiles  & - & list of InfoProfile & - \\
\hline
getInfoProfile & integer & InfoProfile & InvalidInfoProfileId \\
\hline
addInfoProfile & InfoProfile & - & - \\
\hline
removeInfoProfile & integer & - & - \\
\hline
addTrial & Trial & - & - \\
\hline
removeTrial & integer & - & - \\
\hline
getTrials & - & list of Trial & - \\
\hline
getTrial & integer & Trial & - \\
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

name: seq of char\\
email: seq of char\\
infoProfiles: list of PatientInfo\\
trials: list of Trial

\subsubsection{Environment Variables}
None

\subsubsection{Assumptions}
\begin{itemize}
  \item Each InfoProfile has a unique id.
  \item Each Trial has a unique id.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent getName():
\begin{itemize}
\item transition: N/A
\item output: out := self.name
\item exception: N/A
\end{itemize}

\noindent setName(newName: seq of char):
\begin{itemize}
\item transition: self.name := newName
\item output: N/A
\item exception: $exc := length(newName) == 0 \Rightarrow EmptyName$
\end{itemize}

\noindent getEmail():
\begin{itemize}
\item transition: N/A
\item output: out := self.email
\item exception: N/A
\end{itemize}

\noindent setEmail(newEmail: seq of char):
\begin{itemize}
\item transition: self.email := newEmail
\item output: N/A
\item exception: $exc := isInvalidEmail(newEmail) \Rightarrow InvalidEmail$
\end{itemize}

\noindent getInfoProfiles():
\begin{itemize}
\item transition: N/A
\item output: out := self.infoProfiles
\item exception: N/A
\end{itemize}

\noindent getInfoProfile(id: integer):
\begin{itemize}
\item transition: N/A
\item output: out := $\{\exists i \in self.infoProfiles | i.id = id\} \Rightarrow i$
\item exception: exc := $\neg\{\exists i \in self.infoProfiles | i.id = id\} \Rightarrow InvalidInfoProfileId$
\end{itemize}

\noindent addInfoProfile(newInfoProfile: InfoProfile):
\begin{itemize}
\item transition: self.infoProfiles = self.infoProfiles + newInfoProfile
\item output: N/A
\item exception: N/A
\end{itemize}

\noindent removeInfoProfile(oldInfoProfile: InfoProfile):
\begin{itemize}
\item transition: self.infoProfiles = self.infoProfiles - oldInfoProfile
\item output: N/A
\item exception: N/A
\end{itemize}


\subsubsection{Local Functions}

%%%%%%%%%%%%%%% Fetch Trials %%%%%%%%%%%%%%

\section{MIS of the Fetch Trials Modules} \label{User}

\subsection{Module}

TrialFetcher

\subsection{Uses}


\subsection{Syntax}

\subsubsection{Exported Constants}
None

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{4cm} p{4cm} p{4cm} p{4cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
getTrials & seq. of String, integer, String & DataFrame & MissingParameter, InvalidAge, InvalidAddress \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
locator: geopy.geocoder \\

\subsubsection{Environment Variables}
None

\subsubsection{Assumptions}
\begin{itemize}
  \item Each Trial has a unique id.
  \item The trial API will always be accessible.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent getTrials(conditions: sequence of String, age: int, address: String):
\begin{itemize}
\item transition: None
\item output: out := DataFrame populated with trials from the ClinicalTrials.gov API
\item exception: $exc := (age \notin (0,120] \rightarrow InvalidAge) \lor (\neg checkAddress(address) \rightarrow InvalidAddress) \lor ((\exists x . x \in parameters : x = \varepsilon) \rightarrow MissingParameter)$
\end{itemize}

\subsubsection{Local Functions}
\noindent convertTrialsToDataFrame(rawData: csv):
\begin{itemize}
\item transition: None
\item output: out := rawData formatted as a DataFrame
\item exception: None
\end{itemize}

\noindent checkAddress(address: String):
\begin{itemize}
\item transition: None
\item output: out:= True
\item exception: $exc := (geopy.geolocator(address) = exception \rightarrow False)$
\end{itemize}

%%%%%%%%%%%%%%% Filter Trials %%%%%%%%%%%%%%

\section{MIS of the Trial Filtering Module} \label{User}

\subsection{Module}

TrialFilterer

\subsection{Uses}


\subsection{Syntax}

\subsubsection{Exported Constants}
None

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{4cm} p{4cm} p{4cm} p{4cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
exportTrials & - & json & - \\
\hline
fetchTrials & seq. of String, integer, String & - & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
locator: geopy.geocoder \\
trials: DataFrame

\subsubsection{Environment Variables}
None

\subsubsection{Assumptions}
\begin{itemize}
  \item Each Trial has a unique id.
  \item Exceptions are caught downstream by the TrialFetcher module
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent fetchTrials(conditions: sequence of String, age: int, address: String):
\begin{itemize}
\item transition: self.trials populated with trials via TrialFilterer module
\item output: None
\item exception: None
\end{itemize}

\noindent exportTrials():
\begin{itemize}
\item transition: None
\item output: out:= self.trials as json
\item exception: None
\end{itemize}

\subsubsection{Local Functions}
\noindent cleanAge(stringAge: String):
\begin{itemize}
\item transition: None
\item output: out:= $(inMonths \rightarrow int(stringAge)/12) \rightarrow int(stringAge)$
\item exception:  $exc := stringAge \notin \mathbb{R} \rightarrow InvalidAge$
\end{itemize}

\noindent geodesicDistance(address: geocode, trialLocation: geocode):
\begin{itemize}
\item transition: None
\item output: $out := \arccos(\sin(address.latitude)\cdot\sin(trialLocation.latitude) + \cos(address.latitude)\cdot\cos(ltrialLocation.latitude)\cdot\cos(trialLocation.longitude-address.longitude) ) \cdot 6371000$
\item exception: None
\end{itemize}

\noindent calculateDistance():
\begin{itemize}
\item transition: $self.trials[distance] \mapsto geodesicDistance(address, self.trials[trialLocation])$
\item output: None
\item exception: None
\end{itemize}

\noindent convertToJSON(df: DataFrame):
\begin{itemize}
\item transition: None
\item output:  $df \rightarrow json(df)$
\item exception: None
\end{itemize}





\newpage

\bibliographystyle {plainnat}
\bibliography {../../../refs/References}

\newpage

\section{Appendix} \label{Appendix}

\wss{Extra information if required}

\end{document}